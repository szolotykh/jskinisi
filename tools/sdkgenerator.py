import datetime
import json

# Map of type names to their size in bytes
type_to_size_map = {
    "bool": 1,
    "uint8_t": 1,
    "uint16_t": 2,
    "uint32_t": 4,
    "int8_t": 1,
    "int16_t": 2,
    "int32_t": 4,
    "double": 8,
    "integer": 4,
}

def file_header(version, comment_char="//"):
    return f"""{comment_char} ----------------------------------------------------------------------------
{comment_char} Kinisi motr controller commands.
{comment_char} This file is auto generated by the commands generator from JSON file.
{comment_char} Do not edit this file manually.
{comment_char} Timestamp: { datetime.datetime.now().strftime("%Y-%m-%d %H:%M:00") }
{comment_char} Version: {version}
{comment_char} ----------------------------------------------------------------------------\n\n"""

# Function to validate names for various categories like 'Type', 'Command', etc.
# 'name' is the name to be validated, 'category' specifies the category, and 'context' provides additional information.
def validate_name(name, category, context):
    errors = []
    # Check if the name contains a space
    if " " in name:
        errors.append(f"{category} name '{name}' in {context} contains a space.")
    return errors


# Function to validate a command in the JSON
# 'command' is a dictionary containing the command details
def validate_command(command):
    errors = []
    # Validate the name of the command
    errors.extend(validate_name(command['command'], 'Command', 'commands'))
    # Validate the names and ranges of properties for the command
    for prop in command.get("properties", []):
        errors.extend(validate_name(prop['name'], 'Property', f"command '{command['command']}'"))
        # Check if a range exists and if so, validate it
        if "range" in prop:
            if not isinstance(prop["range"], list) or len(prop["range"]) != 2 or prop["range"][0] > prop["range"][1]:
                errors.append(f"Invalid range '{prop['range']}' in property '{prop['name']}' for command '{command['command']}'.")
    return errors

# Main function to validate the entire JSON
# 'commands_data' is a dictionary containing the JSON data
def validate_json(commands_data):
    errors = []

    # Validate each command in the JSON
    for command in commands_data.get("commands", []):
        errors.extend(validate_command(command))
    return errors

# Map of type names to their corresponding setter functions in the DataView class
type_to_js_setter_func_map = {
    "bool": {
        "set":"setUint8",
        "get":"getUint8"
        },
    "uint8_t": {
        "set":"setUint8",
        "get":"getUint8"
        },
    "uint16_t": {
        "set":"setUint16",
        "get":"getUint16"
        },
    "uint32_t": {
        "set":"setUint32",
        "get":"getUint32"
        },
    "int8_t": {
        "set":"setInt8", 
        "get":"getInt8"
        },
    'int16_t': {
        "set":"setInt16",
        "get":"getInt16"
        },
    'int32_t': {
        "set":"setInt32",
        "get":"getInt32"
        },
    "double": {
        "set":"setFloat64",
        "get":"getFloat64"
        }
    }

# Calculates object size
def get_object_size(object_data):
    size = 0
    for prop in object_data.get("properties", []):
        size += type_to_size_map.get(prop['type'])
    return size

# Get object name in pascal case
def get_object_name(object_data):
    # Convert string to pascal case Example motor_controller_state -> MotorControllerState
    return ''.join([word.capitalize() for word in object_data['name'].split('_')])

# Generates JavaScript code for an object
def generate_object(object_data):
    result = ""
    result += f"class {get_object_name(object_data)} {{\n"
    # Generate constructor
    result += "    constructor(\n"
    for prop in object_data.get("properties", []):
        result += f"        {prop['name']},\n"
    result += "    )\n"
    result += "    {\n"
    for prop in object_data.get("properties", []):
        result += f"        this.{prop['name']} = {prop['name']};\n"
    result += "    }\n\n"

    # Generate get size method
    result += "    static getSize() {\n"
    result += f"        return {get_object_size(object_data)};\n"
    result += "    }\n\n"


    # Genetate encode method
    result += "    encode() {\n"
    result += f"        const buffer = new ArrayBuffer(this.getSize());\n"
    result += f"        const view = new DataView(buffer);\n"
    offset = 0
    for prop in object_data.get("properties", []):
        setter_func = type_to_js_setter_func_map[prop['type']].get("set")
        little_endian = ", true" if type_to_size_map[prop['type']] > 1 else ""
        result += f"        view.{setter_func}({offset}, this.{prop['name']}{little_endian});  // {prop['name']}\n"
        offset += type_to_size_map.get(prop['type'], 1)
    result += "        return buffer;\n"
    result += "    }\n\n"

    # Generate decode method
    result += "    static decode(buffer) {\n"
    result += f"        const view = new DataView(buffer);\n"
    result += f"        const obj = new {get_object_name(object_data)}(\n"
    offset = 0
    for prop in object_data.get("properties", []):
        getter_func = type_to_js_setter_func_map[prop['type']].get("get")
        little_endian = ", true" if type_to_size_map[prop['type']] > 1 else ""
        result += f"            view.{getter_func}({offset}{little_endian}),  // {prop['name']}\n"
        offset += type_to_size_map.get(prop['type'], 1)
    result += "        );\n"
    result += "        return obj;\n"
    result += "    }\n"

    result += "}\n\n"
    return result

# Generates JavaScript code from the commands JSON file
def generate_js_code(commands_data, js_verson = ""):
    
    # Generate constants for command codes
    constant_code = ""
    for cmd in commands_data['commands']:
        constant_code += f"const {cmd['command']} = {cmd['code']}\n"
    constant_code += "\n"

    # Write abstract methods for write and read
    abstract_methods = "    async write(buffer) {\n"
    abstract_methods += "        throw new Error(\"write method must be implemented\");\n"
    abstract_methods += "    }\n\n"

    abstract_methods += "    async read(numBytes) {\n"
    abstract_methods += "        throw new Error(\"read method must be implemented\");\n"
    abstract_methods += "    }\n\n"

    # Generate objects
    objects = ""
    for obj in commands_data.get("objects", []):
        objects += generate_object(obj)

    # Generate function for each command
    function_code = ""
    for cmd in commands_data['commands']:
        func_args = ', '.join([f"{prop['name']}" for prop in cmd.get('properties', [])])
        func_body = f"    async {cmd['command'].lower()}({func_args}){{\n"

        message_length = 1  # 1 byte for the command code
        for prop in cmd.get("properties", []):
            message_length += type_to_size_map.get(prop['type'], 1)  # Default to 1 byte if type is unknown

        func_body += f"        const messageLength = {message_length};\n"
        func_body += f"        const buffer = new ArrayBuffer(messageLength + 1);\n"
        func_body += f"        const view = new DataView(buffer);\n"

        func_body += f"        view.setUint8(0, messageLength);  // Message length\n"
        func_body += f"        view.setUint8(1, {cmd['code']});  // Command byte\n"

        offset = 2
        for prop in cmd.get("properties", []):
            setter_func = type_to_js_setter_func_map[prop['type']].get("set")
            little_endian = ", true" if type_to_size_map[prop['type']] > 1 else ""
            func_body += f"        view.{setter_func}({offset}, {prop['name']}{little_endian});  // {prop['name']}\n"
            offset += type_to_size_map.get(prop['type'], 1)

        func_body += "        await this.write(buffer);\n"

        response = cmd.get("response", None)
        if response != None:
            # Determine the size of the response
            if response['type'] in type_to_size_map:
                func_body += f"        const response_size = {type_to_size_map[response['type']]};\n"
            else:
                func_body += f"        const response_size = {get_object_name(response)}.getSize();\n"

            # Read the response
            func_body += "        const result = await this.read(response_size);\n"

            # Check if the response is a primitive type or an object
            if response['type'] in type_to_js_setter_func_map:
                func_body += "        const dataView = new DataView(result, 0);\n"
                # if type size map is 1, then it is a single byte and we don't need to specify the endianness
                if type_to_size_map[response['type']] == 1:
                    func_body += f"        return dataView.{type_to_js_setter_func_map[response['type']].get('get')}(0);\n"
                else:
                    func_body += f"        return dataView.{type_to_js_setter_func_map[response['type']].get('get')}(0, true);\n"
            else:
                # We can use get_object_name here since response also has a name property
                func_body += f"        return {get_object_name(response)}.decode(result);\n"
                
        func_body += "    }\n\n"
        function_code += func_body

    # Generate the final code
    result = file_header(commands_data['version'])
    result += constant_code
    result += objects
    result += "class Commands {\n"
    result += abstract_methods
    result += function_code
    result += "}\n"

    if js_verson == "ES6":
        exports = "Commands"
        for obj in commands_data.get("objects", []):
            exports += f", {get_object_name(obj)}"

        result += "\n"
        result += f"export {{{exports}}}"
    return result

# Generate python code from the commands from the input JSON file
# input_json_path: Path to the input JSON file containing command definitions.
# output_path: Path to the output file.
def generate(input_json_path, output_path, js_verson = ""):
    try:
        with open(input_json_path, 'r') as file:
            commands_data = json.load(file)
    except json.JSONDecodeError:
        print("Error: Could not decode the input JSON file.")
        return
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return

    validation_errors = validate_json(commands_data)
    if validation_errors:
        print("Validation errors found:")
        for error in validation_errors:
            print(f"- {error}")
        return


    generated_code = generate_js_code(commands_data, js_verson)

    try:
        with open(output_path, 'w') as file:
            file.write(generated_code)
    except Exception as e:
        print(f"An error occurred while writing to the output file: {e}")
        return

    print(f"Code has been generated and saved to {output_path}")